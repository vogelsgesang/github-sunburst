{"version":3,"file":"sunburst.js","sources":["../../app/js/sunburst.js"],"names":["angular","module","directive","$parse","restrict","scope","hierarchy","valueFunction","keyFunction","link","element","attrs","redraw","hierarchyCopy","segmentsData","partition","nodes","segments","mainGroup","datum","selectAll","data","_","filter","d","parent","entered","enter","append","hoveredElementSet","on","mouseenter","style","colorScale","path","transition","duration","attrTween","arcTween","exit","remove","domElement","this","undefined","_x","_dx","x","interpolate","d3","dx","t","b","arc","$parent","$digest","mouseleave","hoveredElementGet","hasOwnProperty","hoveredElement","assign","Error","$watch","newHierarchy","cloneDeep","newValueFunction","value","Function","newKeyFunction","scale","category20","layout","sort","size","Math","PI","svg","startAngle","endAngle","innerRadius","sqrt","y","outerRadius","dy","select","attr","classed"],"mappings":"CAAA,WACE,YACAA,SAAQC,OAAO,wBACdC,UAAU,YAAa,SAAU,SAASC,GACzC,OACEC,SAAU,IACVC,OACEC,UAAW,IACXC,cAAe,IACfC,YAAa,KAEfC,KAAM,SAASJ,EAAOK,EAASC,GA+D7B,QAASC,KAEP,GAAGC,EAAe,CAChB,GAAIC,GAAeC,EAAUC,MAAMH,GAC/BI,EAAWC,EAAUC,MAAMN,GAAeO,UAAU,QACnDC,KAAKC,EAAEC,OAAOT,EAAc,SAASU,GAAI,QAASA,EAAEC,SAAWjB,GAEhEkB,EAAUT,EAASU,QAAQC,OAAO,OACnCC,IACDH,EAAQI,GAAG,aAAcC,GAG3Bd,EACGe,MAAM,OAAQ,SAASR,GAAI,MAAOS,GAAWT,EAAEU,QAC/CF,MAAM,UAAW,SAASR,GAAI,MAAOA,GAAEC,OAAS,QAAQ,SACxDU,aACEC,SAAS,KACTC,UAAU,IAAKC,GAEpBrB,EAASsB,OAAOC,aAEhBtB,GAAUE,UAAU,QAAQoB,SAIhC,QAASF,GAASd,GAGhB,GAAIiB,GAAaC,MACIC,SAAlBF,EAAWG,IAAuCD,SAAnBF,EAAWI,OAC3CJ,EAAWG,GAAKpB,EAAEsB,EAClBL,EAAWI,IAAM,EAEnB,IAAIE,GAAcC,GAAGD,aAAaD,EAAGL,EAAWG,GAAIK,GAAIR,EAAWI,KAAMrB,EACzE,OAAO,UAAS0B,GACd,GAAIC,GAAIJ,EAAYG,EAGpB,OAFAT,GAAWG,GAAKO,EAAEL,EAClBL,EAAWI,IAAMM,EAAEF,GACZG,EAAID,IAIf,QAASpB,GAAWP,GAClBK,EAAkBxB,EAAMgD,QAAS7B,GACjCnB,EAAMgD,QAAQC,UAEhB,QAASC,KACP1B,EAAkBxB,EAAMgD,QAASV,QACjCtC,EAAMgD,QAAQC,UA7GhB,GAAIE,GAAmB3B,CACvB,IAAGlB,EAAM8C,eAAe,oBACtBD,EAAoBrD,EAAOQ,EAAM+C,gBACjC7B,EAAoB2B,EAAkBG,QAClC9B,GACF,KAAM,IAAI+B,OAAM,kCAIpB,IAAI/C,EACJR,GAAMwD,OAAO,YAAa,SAASC,GACjCjD,EAAgBS,EAAEyC,UAAUD,GAC5BlD,MACC,GACHP,EAAMwD,OAAO,gBAAiB,SAASG,GAEnCjD,EAAUkD,MADTD,GAAoBA,YAA4BE,UACjCF,EAEA,WAAa,MAAO,KAEtCpD,KAEF,IAAIJ,EACJH,GAAMwD,OAAO,cAAe,SAASM,GAEjC3D,EADC2D,GAAkBA,YAA0BD,UAC/BC,EAEAxB,QAKlB,IAAIV,GAAae,GAAGoB,MAAMC,aACtBtD,EAAYiC,GAAGsB,OAAOvD,YACvBwD,KAAK,MACLC,MAAM,EAAEC,KAAKC,GAAI,MACjBT,MAAM,WAAc,MAAO,KAC1Bb,EAAMJ,GAAG2B,IAAIvB,MACdwB,WAAW,SAASpD,GAAK,MAAOA,GAAEsB,IAClC+B,SAAS,SAASrD,GAAK,MAAOA,GAAEsB,EAAItB,EAAEyB,KACtC6B,YAAY,SAAStD,GAAK,MAAOiD,MAAKM,KAAKvD,EAAEwD,KAC7CC,YAAY,SAASzD,GAAK,MAAOiD,MAAKM,KAAKvD,EAAEwD,EAAIxD,EAAE0D,MAElDP,EAAM3B,GAAGmC,OAAOzE,EAAQ,IACzBkB,OAAO,OACLwD,KAAK,UAAW,wBAChBA,KAAK,sBAAuB,iBAC7BlE,EAAYyD,EAAI/C,OAAO,IAC3BV,GAAUU,OAAO,UACdwD,KAAK,IAAK,KACVC,QAAQ,oBAAoB,GAE5BxD,IACDX,EAAUY,GAAG,aAAcyB,GAI3BoB,EAAI7C,GAAG,aAAcyB","sourcesContent":["(function() {\n  \"use strict\";\n  angular.module(\"d3charts.sunburst\", [])\n  .directive(\"sunburst\", [\"$parse\", function($parse) {\n    return {\n      restrict: \"E\",\n      scope: {\n        hierarchy: \"=\",\n        valueFunction: \"=\",\n        keyFunction: \"=\"\n      },\n      link: function(scope, element, attrs) {\n        //handle the hoverElement attribute\n        var hoveredElementGet, hoveredElementSet;\n        if(attrs.hasOwnProperty(\"hoveredElement\")) {\n          hoveredElementGet = $parse(attrs.hoveredElement);\n          hoveredElementSet = hoveredElementGet.assign;\n          if(!hoveredElementSet) {\n            throw new Error(\"hoveredElement is un-assignable\");\n          }\n        }\n        //watch the variables and adjust chart if necessary\n        var hierarchyCopy;\n        scope.$watch(\"hierarchy\", function(newHierarchy) {\n          hierarchyCopy = _.cloneDeep(newHierarchy);\n          redraw();\n        }, true);\n        scope.$watch(\"valueFunction\", function(newValueFunction) {\n          if(newValueFunction && newValueFunction instanceof Function) {\n            partition.value(newValueFunction);\n          } else {\n            partition.value(function(d) {return 1;});\n          }\n          redraw();\n        });\n        var keyFunction;\n        scope.$watch(\"keyFunction\", function(newKeyFunction) {\n          if(newKeyFunction && newKeyFunction instanceof Function) {\n            keyFunction = newKeyFunction;\n          } else {\n            keyFunction = undefined;\n          }\n        });\n\n        //create the d3 instances which are reused\n        var colorScale = d3.scale.category20();\n        var partition = d3.layout.partition()\n          .sort(null)\n          .size([2*Math.PI, 100*100])\n          .value(function(d) { return 1; });\n        var arc = d3.svg.arc()\n          .startAngle(function(d) { return d.x; })\n          .endAngle(function(d) { return d.x + d.dx; })\n          .innerRadius(function(d) { return Math.sqrt(d.y); })\n          .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });\n        //create the SVG skeleton\n        var svg = d3.select(element[0])\n          .append(\"svg\")\n            .attr(\"viewBox\", \"-100, -100, 200, 200\")\n            .attr(\"preserveAspectRatio\", \"xMinYMin meet\");\n        var mainGroup = svg.append(\"g\");\n        mainGroup.append(\"circle\")\n          .attr(\"r\", 100)\n          .classed(\"backgroundCircle\", true);\n        //attach a mouseleave listener if hoveredElement is used\n        if(hoveredElementSet) {\n          mainGroup.on(\"mouseleave\", mouseleave);\n          //we must attach to the svg as well, since we could leave the mainGroup\n          //over one of the edges of the svg and in this case mousleave would not fire\n          //on the mainGroup\n          svg.on(\"mouseleave\", mouseleave);\n        }\n        \n        //redraws the chart\n        function redraw() {\n          //adjust the basic layout\n          if(hierarchyCopy) {\n            var segmentsData = partition.nodes(hierarchyCopy);\n            var segments = mainGroup.datum(hierarchyCopy).selectAll(\"path\")\n                .data(_.filter(segmentsData, function(d) {return !!d.parent;}), keyFunction);\n            //ENTER\n            var entered = segments.enter().append(\"path\");\n            if(hoveredElementSet) {\n              entered.on(\"mouseenter\", mouseenter);\n            }\n            //UPDATE + ENTER\n            segments\n              .style(\"fill\", function(d) {return colorScale(d.path);})\n              .style(\"display\", function(d) {return d.parent ? \"block\":\"none\";})\n              .transition()\n                .duration(1000)\n                .attrTween(\"d\", arcTween);\n            //EXIT\n            segments.exit().remove();\n          } else {\n            mainGroup.selectAll(\"path\").remove();\n          }\n        }\n        //Interpolate the arcs in data space.\n        function arcTween(d) {\n          //the previous animation state is stored on the DOM element (this)\n          /*jshint validthis:true*/\n          var domElement = this;\n          if(domElement._x === undefined || domElement._dx === undefined) {\n            domElement._x = d.x;\n            domElement._dx = 0;\n          }\n          var interpolate = d3.interpolate({x: domElement._x, dx: domElement._dx}, d);\n          return function(t) {\n            var b = interpolate(t);\n            domElement._x = b.x;\n            domElement._dx = b.dx;\n            return arc(b);\n          };\n        }\n        //for tracking the currently hovered element\n        function mouseenter(d) {\n          hoveredElementSet(scope.$parent, d);\n          scope.$parent.$digest();\n        }\n        function mouseleave() {\n          hoveredElementSet(scope.$parent, undefined);\n          scope.$parent.$digest();\n        }\n      }\n    };\n  }]);\n})();\n"]}